<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Blobs</title>
  <style>
    :root {
      --ink: #111111;
      --paper: #f4f0e8;
      --sky: #dfe9ff;
      --accent: #ff6f61;
      --blob1: #ffd166;
      --blob2: #7bdff2;
      --blob3: #b8f2a6;
      --blob4: #f5a7ff;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      font-family: "Comic Sans MS", "Chalkboard SE", cursive;
      background: radial-gradient(circle at 20% 20%, var(--sky), var(--paper));
      color: var(--ink);
    }
    #wrap {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      image-rendering: pixelated;
      background:
        radial-gradient(circle at 10% 15%, #ffffff 0 10px, transparent 11px),
        radial-gradient(circle at 80% 30%, #ffffff 0 8px, transparent 9px),
        radial-gradient(circle at 60% 70%, #ffffff 0 12px, transparent 13px),
        linear-gradient(180deg, #eef4ff 0%, #f8f5f0 65%, #f3efe8 100%);
      background-size: 200px 200px, 220px 220px, 260px 260px, 100% 100%;
      background-repeat: repeat, repeat, repeat, no-repeat;
    }
    .hud {
      position: absolute;
      left: 14px;
      top: 12px;
      padding: 10px 14px;
      background: rgba(255, 255, 255, 0.85);
      border: 3px solid var(--ink);
      box-shadow: 4px 4px 0 var(--ink);
      max-width: 320px;
      font-size: 14px;
      line-height: 1.3;
    }
    .hud strong {
      color: var(--accent);
    }
    .center-message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: clamp(20px, 3vw, 32px);
      text-align: center;
      text-shadow: 2px 2px 0 #fff;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <strong>Web Blobs</strong><br />
      Click blobs to shoot web. Auto-pull only.<br />
      Keep up with the scroll or fall to doom.
    </div>
    <div id="message" class="center-message"></div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const message = document.getElementById("message");

    const state = {
      width: 0,
      height: 0,
      dpr: 1,
      time: 0,
      cameraX: 0,
      scrollSpeed: 150,
      gravity: 420,
      attached: false,
      anchor: { x: 0, y: 0 },
      player: {
        x: 160,
        y: 260,
        vx: 0,
        vy: 0,
        radius: 12
      },
      platforms: [],
      lastSpawnX: 0,
      dead: false,
      lastShot: null,
      webPrev: null,
      webPrevDist: null,
      webMinDist: null,
      debugHit: null,
      holding: false,
      startX: 0,
      maxX: 0,
      obstacles: [],
      lastObstacleX: 0,
      score: 0
    };

    const blobColors = ["#ffd166", "#7bdff2", "#b8f2a6", "#f5a7ff", "#ffadad"];

    function resize() {
      state.dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * state.dpr);
      canvas.height = Math.floor(window.innerHeight * state.dpr);
      state.width = window.innerWidth;
      state.height = window.innerHeight;
    }

    function reset() {
      state.time = 0;
      state.cameraX = 0;
      state.player.x = 200;
      state.player.y = window.innerHeight * 0.5;
      state.player.vx = 0;
      state.player.vy = 0;
      state.attached = false;
      state.platforms = [];
      state.lastSpawnX = 0;
      state.dead = false;
      state.obstacles = [];
      state.lastObstacleX = 0;
      state.startX = state.player.x;
      state.maxX = state.player.x;
      state.score = 0;
      state.lastShot = null;
      state.webPrev = null;
      state.webPrevDist = null;
      state.webMinDist = null;
      state.debugHit = null;
      state.holding = false;
      message.textContent = "";
      spawnInitial();
    }

    function spawnInitial() {
      for (let i = 0; i < 16; i++) {
        spawnPlatform();
      }
    }

    function spawnPlatform() {
      const spacing = 80 + Math.random() * 80;
      const x = state.lastSpawnX + spacing + 200;
      const y = 120 + Math.random() * (window.innerHeight - 240);
      const r = 26 + Math.random() * 16;
      state.platforms.push({
        x,
        y,
        r,
        color: blobColors[Math.floor(Math.random() * blobColors.length)]
      });
      state.lastSpawnX = x;
    }

    function spawnObstacle() {
      const spacing = 320 + Math.random() * 260;
      const x = Math.max(state.lastObstacleX, state.lastSpawnX) + spacing + 260;
      const y = 80 + Math.random() * (window.innerHeight - 160);
      const vertical = Math.random() < 0.5;
      const w = vertical ? 26 + Math.random() * 24 : 120 + Math.random() * 120;
      const h = vertical ? 160 + Math.random() * 160 : 24 + Math.random() * 24;
      state.obstacles.push({
        x,
        y,
        w,
        h
      });
      state.lastObstacleX = x;
    }

    function update(dt) {
      if (state.dead) return;

      const player = state.player;
      state.time += dt;
      state.cameraX += state.scrollSpeed * dt;
      if (player.x > state.maxX) {
        state.maxX = player.x;
      }
      state.score = Math.max(0, state.maxX - state.startX);

      player.vy += state.gravity * dt;

      if (state.attached) {
        const dx = state.anchor.x - player.x;
        const dy = state.anchor.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;
        const pullStrength = 18;
        const accel = Math.min(1400, pullStrength * dist);

        player.vx += dirX * accel * dt;
        player.vy += dirY * accel * dt;
        player.vx *= 0.985;
        player.vy *= 0.985;

        if (!state.webPrev) {
          state.webPrev = { dx, dy };
        }
        if (state.webPrevDist === null) {
          state.webPrevDist = dist;
        }
        if (state.webMinDist === null) {
          state.webMinDist = dist;
        }
      }

      player.vx *= 0.996;
      player.vy *= 0.996;

      player.x += player.vx * dt;
      player.y += player.vy * dt;

      if (state.attached) {
        const dx = state.anchor.x - player.x;
        const dy = state.anchor.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const breakRadius = 18;
        if (state.webMinDist !== null && dist < state.webMinDist) {
          state.webMinDist = dist;
        }
        const passedAnchor = state.webMinDist !== null
          && state.webMinDist <= breakRadius
          && dist > state.webMinDist + 4;
        if (dist <= breakRadius || passedAnchor) {
          state.attached = false;
          state.webPrev = null;
          state.webPrevDist = null;
          state.webMinDist = null;
        } else {
          state.webPrev = { dx, dy };
          state.webPrevDist = dist;
          state.webMinDist = state.webMinDist === null ? dist : state.webMinDist;
        }
      }

      if (!state.attached && player.y > window.innerHeight + 80) {
        kill("fell out of the world");
      }

      if (player.x < state.cameraX) {
        kill("got left behind");
      }

      while (state.lastSpawnX < state.cameraX + window.innerWidth * 2) {
        spawnPlatform();
      }

      state.platforms = state.platforms.filter((p) => p.x + p.r > state.cameraX - 80);

      if (state.score >= 3000) {
        while (state.lastObstacleX < state.cameraX + window.innerWidth * 2) {
          spawnObstacle();
        }
        state.obstacles = state.obstacles.filter((o) => o.x + o.w > state.cameraX - 120);
      }

      resolveObstacleCollisions();

      if (state.lastShot) {
        state.lastShot.time -= dt;
        if (state.lastShot.time <= 0) state.lastShot = null;
      }
      if (state.debugHit) {
        state.debugHit.time -= dt;
        if (state.debugHit.time <= 0) state.debugHit = null;
      }
    }

    function resolveObstacleCollisions() {
      const player = state.player;
      const r = player.radius;
      for (const o of state.obstacles) {
        const left = o.x;
        const right = o.x + o.w;
        const top = o.y;
        const bottom = o.y + o.h;

        const closestX = Math.max(left, Math.min(player.x, right));
        const closestY = Math.max(top, Math.min(player.y, bottom));
        const dx = player.x - closestX;
        const dy = player.y - closestY;
        const distSq = dx * dx + dy * dy;
        if (distSq < r * r) {
          const dist = Math.sqrt(distSq) || 1;
          const pushX = dx / dist;
          const pushY = dy / dist;
          const overlap = r - dist;
          player.x += pushX * overlap;
          player.y += pushY * overlap;

          if (Math.abs(pushX) > Math.abs(pushY)) {
            player.vx *= 0.2;
          } else {
            player.vy *= 0.2;
          }
        }
      }
    }

    function kill(reason) {
      state.dead = true;
      state.attached = false;
      message.textContent = `Game over: ${reason}. Click to retry.
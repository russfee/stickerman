<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Blobs</title>
  <style>
    :root {
      --ink: #111111;
      --paper: #f4f0e8;
      --sky: #dfe9ff;
      --accent: #ff6f61;
      --blob1: #ffd166;
      --blob2: #7bdff2;
      --blob3: #b8f2a6;
      --blob4: #f5a7ff;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      font-family: "Comic Sans MS", "Chalkboard SE", cursive;
      background: radial-gradient(circle at 20% 20%, var(--sky), var(--paper));
      color: var(--ink);
    }
    #wrap {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      image-rendering: pixelated;
      background:
        radial-gradient(circle at 10% 15%, #ffffff 0 10px, transparent 11px),
        radial-gradient(circle at 80% 30%, #ffffff 0 8px, transparent 9px),
        radial-gradient(circle at 60% 70%, #ffffff 0 12px, transparent 13px),
        linear-gradient(180deg, #eef4ff 0%, #f8f5f0 65%, #f3efe8 100%);
      background-size: 200px 200px, 220px 220px, 260px 260px, 100% 100%;
      background-repeat: repeat, repeat, repeat, no-repeat;
    }
    .hud {
      position: absolute;
      left: 14px;
      top: 12px;
      padding: 10px 14px;
      background: rgba(255, 255, 255, 0.85);
      border: 3px solid var(--ink);
      box-shadow: 4px 4px 0 var(--ink);
      max-width: 320px;
      font-size: 14px;
      line-height: 1.3;
    }
    .hud strong {
      color: var(--accent);
    }
    .center-message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: clamp(20px, 3vw, 32px);
      text-align: center;
      text-shadow: 2px 2px 0 #fff;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <strong>Web Blobs</strong><br />
      Click blobs to shoot web. Auto-pull only.<br />
      Keep up with the scroll or fall to doom.
    </div>
    <div id="message" class="center-message"></div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const message = document.getElementById("message");

    const state = {
      width: 0,
      height: 0,
      dpr: 1,
      time: 0,
      cameraX: 0,
      scrollSpeed: 150,
      gravity: 420,
      attached: false,
      anchor: { x: 0, y: 0 },
      player: {
        x: 160,
        y: 260,
        vx: 0,
        vy: 0,
        radius: 12,
        angle: 0,
        angleVel: 0
      },
      platforms: [],
      lastSpawnX: 0,
      dead: false,
      lastShot: null,
      webPrev: null,
      webPrevDist: null,
      webMinDist: null,
      debugHit: null,
      holding: false,
      startX: 0,
      maxX: 0,
      obstacles: [],
      lastObstacleX: 0,
      score: 0
    };

    const blobColors = ["#ffd166", "#7bdff2", "#b8f2a6", "#f5a7ff", "#ffadad"];

    function resize() {
      state.dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * state.dpr);
      canvas.height = Math.floor(window.innerHeight * state.dpr);
      state.width = window.innerWidth;
      state.height = window.innerHeight;
    }

    function reset() {
      state.time = 0;
      state.cameraX = 0;
      state.player.x = 200;
      state.player.y = window.innerHeight * 0.5;
      state.player.vx = 0;
      state.player.vy = 0;
      state.player.angle = 0;
      state.player.angleVel = 0;
      state.attached = false;
      state.platforms = [];
      state.lastSpawnX = 0;
      state.dead = false;
      state.obstacles = [];
      state.lastObstacleX = 0;
      state.startX = state.player.x;
      state.maxX = state.player.x;
      state.score = 0;
      state.lastShot = null;
      state.webPrev = null;
      state.webPrevDist = null;
      state.webMinDist = null;
      state.debugHit = null;
      state.holding = false;
      message.textContent = "";
      spawnInitial();
    }

    function spawnInitial() {
      for (let i = 0; i < 16; i++) {
        spawnPlatform();
      }
    }

    function spawnPlatform() {
      const spacing = 80 + Math.random() * 80;
      const x = state.lastSpawnX + spacing + 200;
      const y = 120 + Math.random() * (window.innerHeight - 240);
      const r = 26 + Math.random() * 16;
      state.platforms.push({
        x,
        y,
        r,
        color: blobColors[Math.floor(Math.random() * blobColors.length)]
      });
      state.lastSpawnX = x;
    }

    function spawnObstacle() {
      const spacing = 320 + Math.random() * 260;
      const x = Math.max(state.lastObstacleX, state.lastSpawnX) + spacing + 260;
      const y = 80 + Math.random() * (window.innerHeight - 160);
      const vertical = Math.random() < 0.5;
      const w = vertical ? 26 + Math.random() * 24 : 120 + Math.random() * 120;
      const h = vertical ? 160 + Math.random() * 160 : 24 + Math.random() * 24;
      const speed = 50 + Math.random() * 80;
      const dir = Math.random() < 0.5 ? -1 : 1;
      state.obstacles.push({
        x,
        y,
        w,
        h,
        vy: speed * dir
      });
      state.lastObstacleX = x;
    }

    function update(dt) {
      if (state.dead) return;

      const player = state.player;
      state.time += dt;
      state.cameraX += state.scrollSpeed * dt;
      if (player.x > state.maxX) {
        state.maxX = player.x;
      }
      state.score = Math.max(0, state.maxX - state.startX);

      player.vy += state.gravity * dt;

      if (state.attached) {
        const dx = state.anchor.x - player.x;
        const dy = state.anchor.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;
        const pullStrength = 18;
        const accel = Math.min(1400, pullStrength * dist);

        player.vx += dirX * accel * dt;
        player.vy += dirY * accel * dt;
        player.vx *= 0.985;
        player.vy *= 0.985;

        if (!state.webPrev) {
          state.webPrev = { dx, dy };
        }
        if (state.webPrevDist === null) {
          state.webPrevDist = dist;
        }
        if (state.webMinDist === null) {
          state.webMinDist = dist;
        }
      }

      player.vx *= 0.996;
      player.vy *= 0.996;

      const targetAngle = Math.atan2(player.vy, player.vx);
      const angleDelta = Math.atan2(Math.sin(targetAngle - player.angle), Math.cos(targetAngle - player.angle));
      player.angleVel += angleDelta * 12 * dt;
      player.angleVel *= 0.9;
      player.angle += player.angleVel;

      player.x += player.vx * dt;
      player.y += player.vy * dt;

      if (state.attached) {
        const dx = state.anchor.x - player.x;
        const dy = state.anchor.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const breakRadius = 18;
        if (state.webMinDist !== null && dist < state.webMinDist) {
          state.webMinDist = dist;
        }
        const passedAnchor = state.webMinDist !== null
          && state.webMinDist <= breakRadius
          && dist > state.webMinDist + 4;
        if (dist <= breakRadius || passedAnchor) {
          state.attached = false;
          state.webPrev = null;
          state.webPrevDist = null;
          state.webMinDist = null;
        } else {
          state.webPrev = { dx, dy };
          state.webPrevDist = dist;
          state.webMinDist = state.webMinDist === null ? dist : state.webMinDist;
        }
      }

      if (!state.attached && player.y > window.innerHeight + 80) {
        kill("fell out of the world");
      }

      if (player.x < state.cameraX) {
        kill("got left behind");
      }

      while (state.lastSpawnX < state.cameraX + window.innerWidth * 2) {
        spawnPlatform();
      }

      state.platforms = state.platforms.filter((p) => p.x + p.r > state.cameraX - 80);

      if (state.score >= 3000) {
        while (state.lastObstacleX < state.cameraX + window.innerWidth * 2) {
          spawnObstacle();
        }
        state.obstacles = state.obstacles.filter((o) => o.x + o.w > state.cameraX - 120);
      }

      const obstacleTop = 60;
      const obstacleBottom = window.innerHeight - 60;
      for (const o of state.obstacles) {
        o.y += o.vy * dt;
        if (o.y < obstacleTop) {
          o.y = obstacleTop;
          o.vy *= -1;
        }
        const maxY = obstacleBottom - o.h;
        if (o.y > maxY) {
          o.y = maxY;
          o.vy *= -1;
        }
      }

      resolveObstacleCollisions();

      if (state.lastShot) {
        state.lastShot.time -= dt;
        if (state.lastShot.time <= 0) state.lastShot = null;
      }
      if (state.debugHit) {
        state.debugHit.time -= dt;
        if (state.debugHit.time <= 0) state.debugHit = null;
      }
    }

    function resolveObstacleCollisions() {
      const player = state.player;
      const r = player.radius;
      for (const o of state.obstacles) {
        const left = o.x;
        const right = o.x + o.w;
        const top = o.y;
        const bottom = o.y + o.h;

        const closestX = Math.max(left, Math.min(player.x, right));
        const closestY = Math.max(top, Math.min(player.y, bottom));
        const dx = player.x - closestX;
        const dy = player.y - closestY;
        const distSq = dx * dx + dy * dy;
        if (distSq < r * r) {
          const dist = Math.sqrt(distSq) || 1;
          const pushX = dx / dist;
          const pushY = dy / dist;
          const overlap = r - dist;
          player.x += pushX * overlap;
          player.y += pushY * overlap;

          if (Math.abs(pushX) > Math.abs(pushY)) {
            player.vx *= 0.2;
          } else {
            player.vy *= 0.2;
          }
        }
      }
    }

    function kill(reason) {
      state.dead = true;
      state.attached = false;
      message.textContent = `Game over: ${reason}. Click to retry.`;
    }

    function drawBlob(p) {
      const screenX = p.x - state.cameraX;
      const screenY = p.y;

      ctx.lineWidth = 3;
      ctx.strokeStyle = "#111";
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(screenX, screenY, p.r * 1.1, p.r * 0.9, Math.sin(p.x * 0.01) * 0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(screenX - p.r * 0.25, screenY - p.r * 0.1, 3, 0, Math.PI * 2);
      ctx.arc(screenX + p.r * 0.2, screenY + p.r * 0.05, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawObstacle(o) {
      const screenX = o.x - state.cameraX;
      const screenY = o.y;

      ctx.fillStyle = "#ff2d2d";
      ctx.strokeStyle = "#111";
      ctx.lineWidth = 3;
      ctx.fillRect(screenX, screenY, o.w, o.h);
      ctx.strokeRect(screenX, screenY, o.w, o.h);
    }

    function drawPlayer() {
      const player = state.player;
      const screenX = player.x - state.cameraX;
      const screenY = player.y;
      const tilt = player.angle;
      const sway = Math.max(-1, Math.min(1, player.vx / 360));
      const lean = Math.max(-1, Math.min(1, player.vy / 420));

      if (state.attached) {
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(state.anchor.x - state.cameraX, state.anchor.y);
        ctx.stroke();
      }
      if (state.lastShot) {
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(state.lastShot.x - state.cameraX, state.lastShot.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.strokeStyle = "#111";
      ctx.fillStyle = "#fffdf6";
      ctx.lineWidth = 4;

      ctx.save();
      ctx.translate(screenX, screenY);
      ctx.rotate(tilt * 1.15 + lean * 0.35);

      const headY = -28;
      const neckY = -18;
      const hipY = 18;
      const kneeY = 36;
      const footY = 54;
      const torsoLeanX = sway * 6;
      const hipOffsetX = -sway * 6 + lean * 4;
      const kneeOffsetX = hipOffsetX + sway * 10;

      ctx.beginPath();
      ctx.arc(0, headY, 7.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, neckY);
      ctx.lineTo(torsoLeanX * 0.6, hipY);
      ctx.stroke();

      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(torsoLeanX * 0.2, -6);
      ctx.lineTo(-16 + sway * 8, 6 + Math.sin(state.time * 6) * 3);
      ctx.moveTo(torsoLeanX * 0.2, -6);
      ctx.lineTo(16 + sway * 8, 6 + Math.cos(state.time * 5) * 3);
      ctx.stroke();

      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(torsoLeanX * 0.6, hipY);
      ctx.lineTo(hipOffsetX, kneeY);
      ctx.lineTo(kneeOffsetX - 6, footY);
      ctx.moveTo(torsoLeanX * 0.6, hipY);
      ctx.lineTo(hipOffsetX + 8, kneeY);
      ctx.lineTo(kneeOffsetX + 14, footY + 2);
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      state.platforms.forEach(drawBlob);
      state.obstacles.forEach(drawObstacle);
      drawPlayer();

      if (state.debugHit) {
        const hit = state.debugHit;
        ctx.strokeStyle = hit.hit ? "#1b8a3b" : "#c92a2a";
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(hit.x - state.cameraX, hit.y, hit.r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      const distanceText = `Distance: ${Math.floor(state.score / 10)} m`;
      ctx.save();
      ctx.font = "bold 20px 'Comic Sans MS', 'Chalkboard SE', cursive";
      const metrics = ctx.measureText(distanceText);
      const textX = window.innerWidth - metrics.width - 18;
      const textY = 30;
      ctx.translate(textX + metrics.width / 2, textY);
      ctx.rotate(-0.05);
      ctx.translate(-(textX + metrics.width / 2), -textY);
      ctx.shadowColor = "rgba(255, 0, 0, 0.45)";
      ctx.shadowBlur = 12;
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#fff4a8";
      ctx.strokeText(distanceText, textX, textY);
      ctx.fillStyle = "#111";
      ctx.fillText(distanceText, textX, textY);
      ctx.restore();
    }

    function loop(timestamp) {
      if (!state.lastTime) state.lastTime = timestamp;
      const dt = Math.min(0.03, (timestamp - state.lastTime) / 1000);
      state.lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    function pickPlatform(worldX, worldY) {
      let best = null;
      let bestDist = Infinity;
      for (const p of state.platforms) {
        const dx = worldX - p.x;
        const dy = worldY - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < bestDist) {
          best = p;
          bestDist = dist;
        }
      }
      if (!best) return null;
      const grabDistance = best.r + 12;
      return bestDist <= grabDistance ? best : null;
    }

    function handleShoot(event) {
      if (event.button !== undefined && event.button !== 0) return;
      if (state.dead) {
        reset();
        return;
      }
      state.holding = true;
      const rect = canvas.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;
      const worldX = state.cameraX + screenX;
      const worldY = screenY;
      const target = pickPlatform(worldX, worldY);
      const debugRadius = target ? target.r + 12 : 0;
      state.debugHit = {
        x: target ? target.x : worldX,
        y: target ? target.y : worldY,
        r: debugRadius,
        hit: Boolean(target),
        time: 0.5
      };
      state.lastShot = { x: worldX, y: worldY, time: 0.18 };
      state.webPrev = null;
      state.webPrevDist = null;
      state.webMinDist = null;
      if (target) {
        state.attached = true;
        state.anchor.x = target.x;
        state.anchor.y = target.y;
      } else {
        state.attached = false;
      }
    }

    function handleRelease() {
      state.holding = false;
      state.attached = false;
      state.webPrev = null;
      state.webPrevDist = null;
      state.webMinDist = null;
    }

    canvas.addEventListener("pointerdown", handleShoot);
    window.addEventListener("pointerup", handleRelease);
    window.addEventListener("pointercancel", handleRelease);

    window.addEventListener("resize", () => {
      resize();
      reset();
    });

    resize();
    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
